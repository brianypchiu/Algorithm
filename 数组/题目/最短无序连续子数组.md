# 最短无序连续子数组

题目

```bash
给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

你找到的子数组应是最短的，请输出它的长度。

示例 1:

输入: [2, 6, 4, 8, 10, 9, 15]
输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
说明 :

输入的数组长度范围在 [1, 10,000]。
输入的数组可能包含重复元素 ，所以升序的意思是<=。
```

题解

首先可以使用**暴力法**，遍历子数组，并对其是否为无序连续子数组做判断，然后保存其长度，取最小的那个即可。时间复杂度O(n3)

其次优化的方法是**排序法**，可以把数组复制一下，然后直接排序，然后对比排序之后的数组和之前的数组相比，从那个位置开始不一样的即可。时间复杂度O(nlogn)

再次，优化的方法就需要画图分析思考了，这个算法背后的思想是无序子数组中最小元素的正确位置可以决定左边界，最大元素的正确位置可以决定右边界。因此，首先我们需要找到原数组在哪个位置开始不是升序的。我们从头开始遍历数组，一旦遇到降序的元素，我们记录最小元素为 minmin 。类似的，我们逆序扫描数组 numsnums，当数组出现升序的时候，我们记录最大元素为 maxmax。然后，我们再次遍历 numsnums 数组并通过与其他元素进行比较，来找到 minmin 和 maxmax 在原数组中的正确位置。我们只需要从头开始找到第一个大于 minmin 的元素，从尾开始找到第一个小于 maxmax 的元素，它们之间就是最短无序子数组。

```C++
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        int m = nums[0], n = nums.back(), l = -1, r = -2;
        int len = nums.size();
        for (int i = 1; i < len; ++i)
        {
            m = max(m, nums[i]);
            n = min(n, nums[len - 1 - i]);
            if (m != nums[i]) r = i;
            if (n != nums[len - 1 - i]) l = len - 1 - i;
        }
        return r - l + 1;
    }
};
```
